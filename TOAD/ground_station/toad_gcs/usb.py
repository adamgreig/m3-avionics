"""Handle incoming serial data (logging and parsing).
Gregory Brooks, Matt Coates 2017
"""
import serial
from multiprocessing import Pipe
import sys
import struct
from .toad_packets import *
import time

# Get TOAD ID from range/position packet
def get_toad_id_from_type(packet_type):

    if((packet_type & TOAD_1) == TOAD_1):
        #print("Generated by TOAD 1")
        return TOAD_1

    if((packet_type & TOAD_2) == TOAD_2):
        #print("Generated by TOAD 2")
        return TOAD_2

    if((packet_type & TOAD_3) == TOAD_3):
        #print("Generated by TOAD 3")
        return TOAD_3

    if((packet_type & TOAD_4) == TOAD_4):
        #print("Generated by TOAD 4")
        return TOAD_4

    if((packet_type & TOAD_5) == TOAD_5):
        #print("Generated by TOAD 5")
        return TOAD_5

    if((packet_type & TOAD_6) == TOAD_6):
        #print("Generated by TOAD 6")
        return TOAD_6

def run(gui_pipe, log_pipe, gui_exit):
    """
    Args:

    Returns:

    Raises:
    """
    # Open Serial Port
    #ser = serial.Serial('/dev/ttyACM0')
    counter = 1
    while not gui_exit.is_set():

        # Read in a Log
        #data = ser.read(128)

        ########     TESTING!!!      ########
        data = b''                          #
        if counter % 4 == 0:                #
            data = bytes([MESSAGE_PVT])     #
        elif counter % 4 == 1:              #
            data = bytes([MESSAGE_PSU])     #
        elif counter % 4 == 2:              #
            data = bytes([MESSAGE_RANGING]) #
        elif counter % 4 == 3:              #
            data = bytes([MESSAGE_POSITION])#
        data += bytes([TOAD_6])             #
        data += bytes([counter] * 126)      #
        counter += 1                        #
        if counter > 255:                   #
            counter=0                       #
        time.sleep(0.5)                     #
        ########!!!!!!!!!!!!!!!!!!!!!########

        # Get Message Log Type
        log_type = struct.unpack('<B', data[0:1])

        # Handle PVT Message
        if (log_type == MESSAGE_PVT):
            pvt_message = Pvt_packet(data)
            pvt_message.printout()  # DEBUG
            gui_pipe.send(pvt_message)

        # Handle PSU Message
        if (log_type == MESSAGE_PSU):
            psu_message = Psu_packet(data)
            gui_pipe.send(psu_message)

        # Handle Ranging Packet
        if (log_type == MESSAGE_RANGING):
            ranging_message = Ranging_packet(data)
            gui_pipe.send(ranging_message)

        # Handle Position Packet
        if (log_type == MESSAGE_POSITION):
            pos_message = Position_packet(data)
            gui_pipe.send(pos_message)

        # Handle SR Traffic - RX Packet Logged
        if (log_type == MESSAGE_RX_PACKET):
            ##### Uncomment to print things  #####
            # Get Message Metadata
            # meta_data = struct.unpack('<BI', data[1:6])
            #toad_id = meta_data[1]
            # systick = meta_data[2]
            #systick /= 10000.0

            #print("SR TRAFFIC [RX Packet]:")
            #print("TOAD ID = ", toad_id)
            #print("Timestamp = ", systick, " s")
            #######################################
            rx_type = data[6]

            buf = b''

            # Handle Packet Types
            if ((rx_type & RANGE_PACKET) == RANGE_PACKET):
                buf += bytes([MESSAGE_RANGING])  # Message type
                buf += bytes([get_toad_id_from_type(rx_type)])  # ID of origin
                buf += data[2:6]   # systicks

                buf += data[7:17]  # payload
                sr_ranging_message = Ranging_packet(buf)
                gui_pipe.send(sr_ranging_message)

            if ((rx_type & POSITION_PACKET) == POSITION_PACKET):
                buf += bytes([MESSAGE_POSITION])
                buf += bytes([get_toad_id_from_type(rx_type)])
                buf += data[2:6]

                buf += data[7:22]  # payload
                sr_pos_message = Position_packet(buf)
                gui_pipe_send(sr_pos_message)

        #log raw serial data to file
